<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-code-quality">
  <title>La qualité du code</title>

  <sect1 id="sect-code-quality-introduction">
    <title>Introduction</title>

    <para><indexterm class="startofrange" id="ch09-cq" significance="normal">
        <primary>mesures de qualité de code</primary>
      </indexterm>Rares sont ceux qui nient l’importance de l’écriture d’un
    code de qualité. Un code de grande qualité contient moins de bugs, est
    plus facile à comprendre et plus facile à maintenir. Toutefois, les
    définitions précises de la qualité d’un code peuvent être plus
    subjectives, variant entre organisations, équipes, et même entre individus
    d’une même équipe.</para>

    <para>C’est <indexterm id="I_indexterm9_d1e12711" significance="normal">
        <primary>normes de codage</primary>
      </indexterm> ici que les normes de codage entrent en jeu. Les normes de
    codage sont des règles, parfois relativement arbitraires, qui définissent
    les styles et les conventions de codage qui sont considérées comme
    acceptables au sein d’une équipe ou d’une organisation. Dans beaucoup de
    cas, se mettre d’accord sur un ensemble de normes et les appliquer est
    plus important que les normes elles-mêmes. En effet, un des aspects les
    plus importants de la qualité d’un code est qu’il soit facile à lire et à
    comprendre. Si les développeurs d’une équipe appliquent tous les mêmes
    normes et les mêmes pratiques, le code sera plus lisible au moins pour les
    membres de cette équipe. Et si les normes sont communément utilisées dans
    l’industrie, le code sera d’autant plus lisible pour les nouveaux
    développeurs arrivant dans l’équipe.</para>

    <para>Les normes de codage incluent à la fois des aspects esthétiques
    comme la disposition et la mise en forme du code, les conventions de
    nommage et ainsi de suite, aussi bien que les potentielles mauvaises
    pratiques comme les oublies d’accolades après une condition en Java. Un
    style de codage cohérent réduit les coûts de maintenance, fait un code
    plus propre et plus lisible et permet de travailler plus facilement avec
    du code écrit par d’autres membres de l’équipe.</para>

    <para>Uniquement un développeur expérimenté peut réellement jugé de la
    qualité d’un code dans tous ses aspects. C’est le rôle des revues de code
    et, entre autres, des pratiques comme la programmation en binôme. En
    particulier, uniquement un œil humain peut décider si un bout de code est
    réellement bien écrit et s’il fait réellement ce que les exigences lui
    demandent de faire. Néanmoins, les outils de mesure de qualité de code
    peuvent beaucoup aider. En effet, ce n’est pas réaliste d’essayer de
    forcer des normes de codage sans ce type d’outil.</para>

    <para>Ces outils analysent le code source ou le byte code de votre
    application et vérifient si le code respecte certaines règles. Les mesures
    de qualité de code peuvent englober beaucoup d’aspects de la qualité d’un
    code, des normes de codage et des meilleurs pratiques jusqu’à la
    couverture du code, y compris tout depuis les avertissements du
    compilateur jusqu’aux commentaires TODO entre les deux. Certaines mesures
    se concentrent sur les caractéristiques mesurables de votre code de base,
    comme le nombre de lignes de code (NLOC), la moyenne de complexité du code
    ou le nombre de lignes par classe. D’autres se focalisent sur des analyses
    statiques plus sophistiqués ou sur la recherche de bugs potentiels ou de
    mauvaises pratiques dans votre code.</para>

    <para>Il y a<indexterm id="I_indexterm9_d1e12727" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary>plugins pour</secondary>
      </indexterm> une large gamme de plugins établissant des rapports sur la
    qualité du code disponibles pour Jenkins. Beaucoup sont des outils
    d’analyse statique Java, comme Checkstyle, PMD, FindBugs, Cobertura et
    JDepends. D’autres, comme fxcop et NCover, se focalisent sur les
    applications .NET.</para>

    <para>Avec tous ces outils, vous devais configurer votre tâche de build
    pour générer les données de mesure de qualité de code avant que Jenkins
    puisse produire n’importe quels rapports.</para>

    <para>L’<indexterm id="I_indexterm9_d1e12737" significance="normal">
        <primary>mesures de qualité de code</primary>

        <secondary sortas="Sonar">avec Sonar</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e12742" significance="normal">
        <primary>Sonar</primary>

        <secondary>mesures de qualité de code avec</secondary>
      </indexterm>exception notable de cette règle est Sonar. Sonar peut
    extraire des mesures de qualité de code depuis n’importe quel projet, sans
    aucunes configurations supplémentaires dans votre projet Maven. Ce qui est
    excellent lorsque vous avez un nombre important de projets Maven existant
    qui doivent être intégrés à Jenkins et que vous voulez configurer des
    rapports de qualité de code cohérents sur tous les projets.</para>

    <para>Dans le reste de ce chapitre, vous verrez comment configurer des
    rapports de qualité de code dans vos builds Jenkins et également comment
    l’utiliser comme un élément efficace dans votre processus de build.</para>
  </sect1>

  <sect1 id="sect-code-quality-build-process">
    <title>La qualité du code dans votre processus de build</title>

    <para>Avant de voir comment rapporter les mesures de qualités dans
    Jenkins, cela peut être utile de revenir en arrière pour avoir une vue
    plus large. Les mesures de la qualité du code sont d’une valeur limitée en
    isolation, elles doivent faire partie d’une stratégie plus large
    d’amélioration des processus.</para>

    <para>Le<indexterm id="I_indexterm9_d1e12757" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary sortas="IDE">avec l'EDI</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e12762" significance="normal">
        <primary>EDI, mesures de qualité de code avec</primary>
      </indexterm> premier niveau d’intégration de la qualité du code devrait
    être l’EDI. Les EDI modernes ont un excellent support de beaucoup d’outils
    de qualité de code — Checkstyle, PMD et FindBugs ont tous des plugins pour
    Eclipse, NetBeans et IntelliJ, qui fournissent un retour d’information
    rapide aux développeurs sur les problèmes de qualité du code. C’est le
    moyen le plus rapide et le plus efficace pour fournir un retour
    d’information à des développeurs individuels et pour enseigner aux
    développeurs les normes de codage de l’organisation ou du projet.</para>

    <para>Le <indexterm id="I_indexterm9_d1e12774" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary sortas="build jobs">dans les tâches de build</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e12779" significance="normal">
        <primary>les tâches de build</primary>

        <secondary>les mesures de qualité de code dans</secondary>

        <see>les mesures de qualité de code</see>
      </indexterm>second niveau est votre serveur de build. En plus de vos
    tâches de builds de tests unitaires et d’intégration normales, mettez en
    place un build de qualité de code dédié, qui démarrera après le build
    normal et les tests. Le but de ce processus est de fournir des mesures de
    qualité de code à l’échelle du projet, de garder un œil sur la façon dont
    le projet est trait d’être fait dans son ensemble et de traiter n’importe
    quels problèmes d’un niveau élevé. L’efficacité des ces rapports peut être
    augmentée par une revue de qualité de code hebdomadaire, dans lesquelles
    les problèmes et les tendances sur de qualité du code sont discutées au
    sein de l’équipe.</para>

    <para>C’est important de démarrer cette tâche séparément parce que les
    outils d’analyse de couverture de code et d’analyse statique peuvent être
    très longs à exécuter. Il est également important de garder n’importe
    quels tests de couverture du code bien loin des builds, puisque le
    processus de couverture du code produit du code instrumenté qui ne devrait
    jamais être déployé vers un dépôt pour une utilisation en
    production.</para>

    <para>L’établissement de rapports sur la de qualité de code est, par
    défaut, un processus relativement passif. Personne ne connaîtra l’état du
    projet s’ils ne cherchent pas l’information sur le serveur de build. Même
    si c’est mieux que rien, si vous êtes sérieux concernant la qualité du
    code, il y a un meilleur moyen. Au lieu de simplement établir des rapports
    sur la qualité du code, mettez en place un build dédié à la qualité du
    code, qui démarre après le build normal et les tests et configurez le
    build pour échouer si les mesures de la qualité du code ne sont pas à un
    niveau acceptable. Vous pouvez faire cela dans Jenkins ou dans votre
    script de build, bien qu’un avantage de le configurer en dehors de votre
    script de build soit que vous pouvez changer les critères de défaillance
    du build de qualité du code sans changer le code source du projet.</para>

    <para>Comme dernier mot, souvenez vous que les normes de codage sont des
    lignes directrices et des recommandations, pas des règles absolues.
    Utilisez la défaillance des builds et les rapports de qualité de code
    comme des indicateurs d’une zone possible d’amélioration, non pas comme
    des mesures de valeur <indexterm class="endofrange"
        id="I_indexterm9_d1e12793" significance="normal" startref="ch09-cq">
        <primary/>
      </indexterm> absolue.</para>
  </sect1>

  <sect1 id="sect-code-quality-tools">
    <title>Les outils d’analyse de qualité du code populaires pour Java et
    Groovy</title>

    <para>Il y a beaucoup d’outils open source qui peuvent aider à identifier
    des mauvaises pratiques de codage.</para>

    <para>Dans<indexterm id="I_indexterm9_d1e12803" significance="normal">
        <primary>mesures de qualité de code</primary>

        <secondary>logiciel pour</secondary>
      </indexterm> le monde Java, trois outils d’analyses statiques ont
    résisté à l’épreuve du temps, et sont largement utilisés de manière très
    complémentaire. Checkstyle excelle dans la vérification des conventions et
    normes de codage, les pratiques de codage, aussi bien que d’autres mesures
    telles que la complexité du code. PMD est un outil d’analyse statique
    similaire à Checkstyle, plus focalisé sur les pratiques de codage et de
    conception. Et FindBugs est un outil innovant, issu de la recherche en
    cours du projet de Bill Pugh et son équipe de l’université du Maryland qui
    se focalise sur l’identification du code dangereux et bogué. Et si vous
    être en train de travailler avec Groovy ou Grails, vous pouvez utiliser
    CodeNarc, qui vérifie la norme et les pratiques de codage de
    Groovy.</para>

    <para>Tous ces outils peuvent être facilement intégrés dans votre
    processus de build. Dans les sections suivantes, nous verrons comment
    configurer ces outils pour générer des rapports XML que Jenkins peut
    ensuite utiliser dans ces propres rapports</para>

    <sect2>
      <title>Checkstyle</title>

      <para><ulink url="http://checkstyle.sourceforge.net">Checkstyle</ulink>
      est<indexterm class="startofrange" id="ch09-check1"
          significance="normal">
          <primary>Checkstyle</primary>
        </indexterm><indexterm class="startofrange" id="ch09-check2"
          significance="normal">
          <primary>mesures de qualité de code</primary>

          <secondary sortas="Checkstyle">avec Checkstyle</secondary>
        </indexterm> un outil d’analyse statique pour Java. A l’origine conçu
      pour faire respecter un ensemble de normes de codage hautement
      configurable, Checkstyle permet maintenant aussi de vérifier les
      mauvaises pratiques de codage, aussi bien que le code trop complexe ou
      dupliqué. Checkstyle est un outil versatile et flexible qui devrait
      avoir sa place dans n’importe quelle stratégie d’analyse de code basé
      sur Java.</para>

      <para>Checkstyle supporte un très grand nombre de lois, incluant celles
      liées aux normes de nommage, annotations, commentaires javadoc, taille
      de méthode et de classe, mesures de complexité de code, mauvaises
      pratiques de codage, et beaucoup d’autres.</para>

      <para>Le code dupliqué est un autre problème important de la qualité de
      code — le code dupliqué ou quasi-dupliqué est plus difficile à maintenir
      et à déboguer. Checkstyle fournit un certain soutien pour la détection
      de code dupliqué, mais des outils plus spécialisés comme CPD font un
      meilleur travail dans ce domaine.</para>

      <para>Une des belles choses au sujet de Checkstyle est comment il est
      facile à configurer. Vous pouvez commencer avec les normes de codage de
      Sun et les adapter selon vos besoins, ou démarrer de zéro. En utilisant
      <indexterm id="I_indexterm9_d1e12836" significance="normal">
          <primary>Eclipse</primary>

          <secondary>code quality metrics with Checkstyle</secondary>
        </indexterm>le plugin Eclipse (ou même directement en XML), vous
      pouvez choisir parmi plusieurs centaines de règles, et affiner les
      options des règles que vous choisissez (voir <xref
      linkend="fig-hudson-quality-checkstyle"/>). C’est important, comme des
      organisations, des équipes ou même des projets ont des attentes et des
      préférences différentes au regard des normes de codage, et c’est mieux
      d’avoir un ensemble de règles précises qui peuvent être adoptées, plutôt
      que un large éventail de règles qui seront ignorées. C’est spécialement
      important lorsque de grandes bases de code existant sont impliquées —
      dans ces cas, il est souvent préférable de commencer avec un ensemble
      plus limité de règles que d’être submergé par un grand nombre de
      problèmes de formatage relativement mineur.</para>

      <figure float="none" id="fig-hudson-quality-checkstyle">
        <title>C’est facile de configurer les règles Checkstyle avec
        Eclipse</title>

        <mediaobject id="I_mediaobject9_d1e12847">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0901.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0901.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Configurer Checkstyle dans votre build est généralement simple. Si
      <indexterm id="I_indexterm9_d1e12854" significance="normal">
          <primary>Ant</primary>

          <secondary>code quality metrics</secondary>

          <tertiary sortas="Checkstyle">with Checkstyle</tertiary>
        </indexterm>vous utilisez Ant, vous avez besoin de télécharger le
      fichier JAR de Checkstyle depuis le site web et de le rendre disponible
      à Ant. Vous pourriez le placer dans votre répertoire <filename
      moreinfo="none">lib</filename> de Ant, mais cela signifierait de devoir
      personnaliser l’installation de Ant sur votre serveur de build (et tout
      les nœuds esclaves), ce n’est donc pas une solution très portable. Une
      meilleure approche serait de placer le fichier JAR de Checkstyle dans
      l’un de vos répertoires du projet, ou d’utiliser Ivy ou la librairie
      Maven Ant Task pour déclarer une dépendance à Checkstyle. Si vous optez
      pour garder le fichier JAR de Checkstyle dans les répertoires du projet,
      vous pouvez déclarer la tâche Checkstyle comme indiqué ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e12868">          &lt;taskdef resource="checkstyletask.properties"
               classpath="lib/checkstyle-5.3-all.jar"/&gt;</programlisting>

      <para>Ensuite, pour générer les rapports Checkstyle dans le format XML
      que Jenkins peut utiliser, vous pouvez procéder comme suit :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e12872">&lt;target name="checkstyle"&gt;
  &lt;checkstyle config="src/main/config/company-checks.xml"&gt;
    &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
    &lt;formatter type="plain"/&gt; 
    &lt;formatter type="xml"/&gt;
  &lt;/checkstyle&gt;
&lt;/target&gt;</programlisting>

      <para>Maintenant, invoquez juste cette tâche (e.g., <literal
      moreinfo="none">ant checkstyle</literal>) afin de générer les rapports
      Checkstyle.</para>

      <para>Dans <indexterm id="I_indexterm9_d1e12882" significance="normal">
          <primary>Maven</primary>

          <secondary>code quality metrics</secondary>

          <tertiary sortas="Checkstyle">with Checkstyle</tertiary>
        </indexterm>Maven 2, vous pouvez ajouter quelque chose comme la
      section <code>&lt;reporting&gt;</code> qui suit :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e12893">&lt;reporting&gt;
  &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.4&lt;/version&gt;
        &lt;configuration&gt;
          &lt;configLocation&gt;
            src/main/config/company-checks.xml
          &lt;/configLocation&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting>

      <para>Pour un projet Maven 3, vous avez besoin d’ajouter un plugin sur
      l’élément <code>&lt;reportPlugins&gt;</code> de la section
      <code>&lt;configuration&gt;</code> du <emphasis>maven-site-plugin
      </emphasis>:</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e12906">&lt;project&gt;
  &lt;properties&gt;
    &lt;sonar.url&gt;http://buildserver.acme.org:9000&lt;/sonar.url&gt;
  &lt;/properties&gt;
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.0-beta-2&lt;/version&gt;
        &lt;configuration&gt;
         &lt;reportPlugins&gt;
          &lt;plugin&gt;
           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
           &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
           &lt;configuration&gt;
            &lt;configLocation&gt;
              ${sonar.url}/rules_configuration/export/java/My_Rules/checkstyle.xml
            &lt;/configLocation&gt;
           &lt;/configuration&gt;
          &lt;/plugin&gt;
         &lt;/reportPlugins&gt;
        &lt;/configuration&gt;
       &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>Maintenant, l’exécution de <literal moreinfo="none">mvn
      checkstyle:checkstyle</literal> ou <literal moreinfo="none">mvn
      site</literal> analysera votre code source et génèrera des rapports XML
      que Jenkins peut utiliser.</para>

      <para>A noter que dans le dernier exemple, nous utilisons un ensemble de
      règles de Checkstyle que nous avons transféré sur un serveur Sonar
      (définie par la propriété <literal
      moreinfo="none">${sonar.url}</literal>). Cette stratégie rend facile
      l’utilisation du même ensemble des règles Checkstyle pour Eclipse,
      Maven, Jenkins, et Sonar.</para>

      <para>Les <indexterm id="I_indexterm9_d1e12923" significance="normal">
          <primary>Gradle</primary>

          <secondary>code quality metrics</secondary>

          <tertiary sortas="Checkstyle">with Checkstyle</tertiary>
        </indexterm> versions récentes de Gradle offrent aussi une certaine
      prise en charge intégrée de Checkstyle. Vous pouvez configurer pour vos
      builds comme indiquer :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e12931">apply plugin: 'code-quality'</programlisting>

      <para>Cela utilisera l’ensemble de règle de Checkstyle dans <filename
      moreinfo="none">config/checkstyle/checkstyle.xml</filename> par défaut.
      Vous pouvez redéfinir cela avec la propriété
      <code>checkstyleConfigFileName</code> : au moment de l’écriture de ce
      livre, cependant, vous ne pouvez télécharger le plugin de qualité de
      code de Gradle pour obtenir les règles Checkstyle à partir d’une
      URL.</para>

      <para>Vous pouvez générer les rapports Checkstyle ici <indexterm
          class="endofrange" id="I_indexterm9_d1e12943" significance="normal"
          startref="ch09-check1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e12945"
          significance="normal" startref="ch09-check2">
          <primary/>
        </indexterm>en exécutant <literal moreinfo="none">gradle
      checkstyleMain</literal> or <literal moreinfo="none">gradle
      check</literal>.</para>
    </sect2>

    <sect2>
      <title>PMD/CPD</title>

      <para><ulink url="http://pmd.sourceforge.net">PMD</ulink> est <indexterm
          class="startofrange" id="ch09-pmd1" significance="normal">
          <primary>PMD</primary>
        </indexterm><indexterm class="startofrange" id="ch09-pmd2"
          significance="normal">
          <primary>mesures de qualité de code</primary>

          <secondary sortas="PMD">avec PMD</secondary>
        </indexterm> un autre outil populaire d’analyse statique. Il se
      focalise sur les problèmes potentiels de codage comme le code non
      utilisé ou sous-optimisé, la taille et la complexité du code, et les
      bonnes pratiques de codage. Certaines règles typiques intègrent « Empty
      If Statement », « Broken Null Check », « Avoid Deeply Nested If
      Statements, « Switch Statements Should Have Default», et « Logger Is Not
      Static Final ». Il y a une bonne quantité de ressemblances avec
      certaines règles de Checkstyle, bien que PMD a quelques règles plus
      techniques, et d’autres plus spécialisées tels que les règles relatives
      à JSF et Android.</para>

      <para>PMD <indexterm class="startofrange" id="ch09-cpd1"
          significance="normal">
          <primary>CPD</primary>
        </indexterm><indexterm class="startofrange" id="ch09-cpd2"
          significance="normal">
          <primary>mesures de qualité de code</primary>

          <secondary sortas="CPD">avec CPD</secondary>
        </indexterm>est aussi livré avec CPD, détecteur open source robuste de
      code dupliqué ou quasi-dupliqué.</para>

      <?dbfo-need height=”1in”?>

      <para>PMD est un peu moins flexible que Checkstyle, bien que vous pouvez
      choisir les règles que vous voulez utiliser dans <indexterm
          id="I_indexterm9_d1e12984" significance="normal">
          <primary>Eclipse</primary>

          <secondary>mesures de qualité de code avec PMD</secondary>
        </indexterm> Eclipse, et après les exporter comme un fichier XML (voir
      <xref linkend="fig-hudson-quality-pmd"/>). Vous pouvez alors importer
      ces règles dans les autres projets Eclipse, dans Sonar, ou les utiliser
      dans vos builds Ant ou Maven.</para>

      <figure float="none" id="fig-hudson-quality-pmd">
        <title>Configurer les règles PMD dans Eclipse</title>

        <mediaobject id="I_mediaobject9_d1e12995">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0902.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0902.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>PMD <indexterm id="I_indexterm9_d1e13002" significance="normal">
          <primary>Ant</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="PMD">avec PMD et CPD</tertiary>
        </indexterm>est livré avec une tâche Ant que vous pouvez utiliser pour
      générer les rapports PMD et CPD. Tout d’abord, si, vous avez besoin de
      définir ces tâches, comme le montre l’exemple suivant :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13010">&lt;path id="pmd.classpath"&gt;
    &lt;pathelement location="${build}"/&gt;
    &lt;fileset dir="lib/pmd"&gt;
        &lt;include name="*.jar"/&gt;
    &lt;/fileset&gt;
&lt;/path&gt;

&lt;taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask" 
         classpathref="pmd.classpath"/&gt;

 &lt;taskdef name="cpd" classname="net.sourceforge.pmd.cpd.CPDTask" 
          classpathref="pmd.classpath"/&gt;</programlisting>

      <?dbfo-need height=”2in”?>

      <para>Ensuite, vous pouvez générer le rapport PMD XML en invoquant la
      tâche PMD comme illustré ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13015">&lt;target name="pmd"&gt;
 &lt;taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask" 
          classpathref="pmd.classpath"/&gt;

 &lt;pmd rulesetfiles="basic" shortFilenames="true"&gt;
  &lt;formatter type="xml" toFile="target/pmd.xml" /&gt;
  &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
 &lt;/pmd&gt;
&lt;/target&gt;</programlisting>

      <para>Et, pour générer le rapport CPD XML, vous pouvez quelque chose
      comme ça :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13020">&lt;target name="cpd"&gt;
  &lt;cpd minimumTokenCount="100" format="xml" outputFile="/target/cpd.xml"&gt;
    &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
  &lt;/cpd&gt;
&lt;/target&gt;</programlisting>

      <para>Vous pouvez placer l’ensemble de ces règles XML dans le classpath
      de votre projet (par exemple, dans <code>src/main/resources</code> pour
      un projet Maven), ou dans un module séparé (si vous voulez partager la
      configuration entre les projets). Un exemple de la façon de configurer
      Maven 2 pour générer des rapports PMD et CPD en utilisant un ensemble de
      règles XML exporté est indiqué ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13027">&lt;reporting&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
      &lt;configuration&gt;
        &lt;!-- PMD options --&gt;
        &lt;targetJdk&gt;1.6&lt;/targetJdk&gt;
        &lt;aggregate&gt;true&lt;/aggregate&gt;
        &lt;format&gt;xml&lt;/format&gt;
        &lt;rulesets&gt;
          &lt;ruleset&gt;/pmd-rules.xml&lt;/ruleset&gt;
        &lt;/rulesets&gt;

        &lt;!-- CPD options --&gt;
        &lt;minimumTokens&gt;20&lt;/minimumTokens&gt;
        &lt;ignoreIdentifiers&gt;true&lt;/ignoreIdentifiers&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting>

      <para>Si <indexterm id="I_indexterm9_d1e13031" significance="normal">
          <primary>Maven</primary>

          <secondary>code quality metrics</secondary>

          <tertiary sortas="PMD">with PMD and CPD</tertiary>
        </indexterm> vous utilisez Maven 3, vous devez placer la définition du
      plugin dans la section de configuration
      <code>&lt;maven-site-plugin&gt;</code>. Cet exemple montre aussi comment
      utiliser un ensemble de règles dans une autre dépendance (dans ce cas,
      le fichier <filename moreinfo="none">pmd-rules.jar</filename>):</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13045">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0-beta-2&lt;/version&gt;
          &lt;configuration&gt;
            &lt;reportPlugins&gt;
              &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.5&lt;/version&gt;
                &lt;configuration&gt;
                  &lt;!-- PMD options --&gt;
                  &lt;targetJdk&gt;1.6&lt;/targetJdk&gt;
                  &lt;aggregate&gt;true&lt;/aggregate&gt;
                  &lt;format&gt;xml&lt;/format&gt;
                  &lt;rulesets&gt;
                    &lt;ruleset&gt;/pmd-rules.xml&lt;/ruleset&gt;
                  &lt;/rulesets&gt;

                  &lt;!-- CPD options --&gt;
                  &lt;minimumTokens&gt;50&lt;/minimumTokens&gt;
                  &lt;ignoreIdentifiers&gt;true&lt;/ignoreIdentifiers&gt;
                &lt;/configuration&gt;
              &lt;/plugin&gt;
            &lt;/reportPlugins&gt;
          &lt;/configuration&gt;
          &lt;dependencies&gt;
            &lt;dependency&gt;
              &lt;groupId&gt;com.wakaleo.code-quality&lt;/groupId&gt;
              &lt;artifactId&gt;pmd-rules&lt;/artifactId&gt;
              &lt;version&gt;1.0.1&lt;/version&gt;
            &lt;/dependency&gt;
          &lt;/dependencies&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>Maintenant, vous pouvez démarrer soit <literal moreinfo="none">mvn
      site</literal> ou <literal moreinfo="none">mvn pmd:pmd pmd:cpd</literal>
      pour générer les rapport PMD et CPD.</para>

      <para>Malheureusement il n’existe actuellement aucune prise en charge de
      Gradle pour PMD ou CPD, vous devez donc vous rabattre en appelant le
      plugin PMD Ant directement, comme montré ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13057">configurations {
    pmdConf
}

dependencies {
    pmdConf 'pmd:pmd:4.2.5'
}

task pmd &lt;&lt; {
    println 'Running PMD static code analysis'
    ant {
        taskdef(name:'pmd', classname:'net.sourceforge.pmd.ant.PMDTask', 
                classpath: configurations.pmdConf.asPath)

        taskdef(name:'cpd', classname:'net.sourceforge.pmd.cpd.CPDTask', 
                        classpath: configurations.pmdConf.asPath)

        pmd(shortFilenames:'true', failonruleviolation:'false', 
            rulesetfiles:'conf/pmd-rules.xml') {
            formatter(type:'xml', toFile:'build/pmd.xml')
            fileset(dir: "src/main/java") {
                include(name: '**/*.java')
            }
            fileset(dir: "src/test/java") {
                include(name: '**/*.java')
            }
        }

        cpd(minimumTokenCount:'50', format: 'xml',
            ignoreIdentifiers: 'true',
            outputFile:'build/cpd.xml') {
            fileset(dir: "src/main/java") {
                include(name: '**/*.java')
            }
            fileset(dir: "src/test/java") {
                include(name: '**/*.java')
            }        
        }
    }
}</programlisting>

      <para>Cette configuration utilisera la règle PMD configuré dans le
      répertoire <filename moreinfo="none">src/config</filename>, et génèrera
      un rapport PMD XML appelé <filename moreinfo="none">pmd.xml</filename>
      dans le répertoire <filename moreinfo="none">build</filename>. Il
      démarrera aussi CPD et générera un rapport CPD XML <indexterm
          class="endofrange" id="I_indexterm9_d1e13070" significance="normal"
          startref="ch09-pmd1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13072"
          significance="normal" startref="ch09-pmd2">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13074"
          significance="normal" startref="ch09-cpd1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13076"
          significance="normal" startref="ch09-cpd2">
          <primary/>
        </indexterm>appelé <filename moreinfo="none">cpd.xml</filename> dans
      le répertoire <filename moreinfo="none">build</filename>.</para>
    </sect2>

    <sect2>
      <title>FindBugs</title>

      <para>FindBugs<indexterm class="startofrange" id="ch09-find1"
          significance="normal">
          <primary>FindBugs</primary>
        </indexterm><indexterm class="startofrange" id="ch09-find2"
          significance="normal">
          <primary>mesures de qualité de code</primary>

          <secondary sortas="FindBugs">avec FindBugs</secondary>
        </indexterm>un puissant outil d’analyse de code qui vérifie le byte
      code de votre application pour contre bogues potentiels, des problèmes
      de performances, ou des mauvaises habitudes de codage. FindBugs est le
      résultat d’une recherche effectuée à l’université du Maryland menée par
      Bill Pugh, qui étudie les modèles de byte code venant de bogues dans de
      réels grand projets, comme les JDKs, Eclipse, et le code source
      d’applications Google. FindBugs peut détecter des problèmes assez
      importants tels que des exceptions de pointeurs nuls, des boucles
      infinies, et un accès non intentionnel de l’état interne d’un objet.
      Contrairement à beaucoup d’autres outils d’analyse statique, FindBugs
      tend à trouver un plus petit nombre de problèmes, mais de ces problèmes,
      une grande partie sera importante.</para>

      <para>FIndBugs est moins configurable que les autres outils que nous
      avons vu, mais en pratique vous n’avez généralement pas besoin d’affiner
      les règles autant que les autres outils dont nous avons discuté. Vous
      pouvez lister les règles individuelles que vous voulez appliquer, mais
      vous ne pouvez pas configurer un fichier XML partagé entre vos builds
      Maven et votre IDE, par exemple.</para>

      <para>FindBugs <indexterm id="I_indexterm9_d1e13107"
          significance="normal">
          <primary>Ant</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="FindBugs">avec FindBugs</tertiary>
        </indexterm>est livrée empaqueté avec une tâche Ant. Vous pouvez
      définir la tâche FindBugs dans Ant comme montré en dessous. FindBugs a
      besoin de référencer le répertoire home de FindBugs, qui est où la
      distribution binaire a été décompressée. Pour faire le build plus
      portable, nous stockons l’installation de FIndBugs dans notre structure
      de répertoire du projet, dans le répertoire <filename
      moreinfo="none">tools/findbugs</filename> :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13118">&lt;property name="findbugs.home" value="tools/findbugs" /&gt;

&lt;taskdef name="findbugs" classname="edu.umd.cs.findbugs.anttask.FindBugsTask" &gt; 
  &lt;classpath&gt;
    &lt;fileset dir="${findbugs.home}/lib" includes="**/*.jar"/&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;</programlisting>

      <para>Puis, pour démarre FindBugs, vous pouvez configurer une cible
      ‘findbugs’ comme montré dans l’exemple suivant. A noter que FindBugs
      démarrer sur le byte-code de votre application, pas le code source, donc
      vous avez besoin de compiler votre code source dans un premier temps
      :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13122">&lt;target name="findbugs" depends="compile"&gt; 
  &lt;findbugs home="${findbugs.home}" output="xml" outputFile="target/findbugs.xml"&gt;
    &lt;class location="${classes.dir}" /&gt; 
    &lt;auxClasspath refId="dependency.classpath" /&gt; 
    &lt;sourcePath path="src/main/java" /&gt;
  &lt;/findbugs&gt;
&lt;/target&gt;</programlisting>

      <para>Si <indexterm id="I_indexterm9_d1e13126" significance="normal">
          <primary>Maven</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="FindBugs">avec FindBugs</tertiary>
        </indexterm>vous utiliser Maven 2, vous n’avez pas besoin de garder
      une copie locale de l’installation de FindBugs. Vous avez juste qu’à
      configurer FindBugs dans la section reporting comme montré ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13134">&lt;reporting&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;2.3.1&lt;/version&gt;
      &lt;configuration&gt;
        &lt;effort&gt;Max&lt;/effort&gt;
        &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting>

      <para>Ou pour un projet Maven 3 :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13138">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0-beta-2&lt;/version&gt;
          &lt;configuration&gt;
            &lt;reportPlugins&gt;
                &lt;plugin&gt;
                  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                  &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
                  &lt;version&gt;2.3.1&lt;/version&gt;
                  &lt;configuration&gt;
                    &lt;effort&gt;Max&lt;/effort&gt;
                    &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;
                  &lt;/configuration&gt;
                &lt;/plugin&gt;
            &lt;/reportPlugins&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>Dans les deux cas, vous pouvez générer vos rapports XML en
      démarrant <literal moreinfo="none">mvn site</literal> ou <literal
      moreinfo="none">mvn findbugs:findbugs</literal>. Les rapports XML seront
      placés dans le répertoire <filename
      moreinfo="none">target</filename>.</para>

      <para>Au moment de la rédaction, il n’y a pas de prise en charge de
      FindBugs dans Gradle, donc vous devez invoquer le plugin Ant de
      FindBugs<indexterm class="endofrange" id="I_indexterm9_d1e13154"
          significance="normal" startref="ch09-find1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13156"
          significance="normal" startref="ch09-find2">
          <primary/>
        </indexterm>.</para>
    </sect2>

    <sect2>
      <title>CodeNarc</title>

      <para>CodeNarc<indexterm class="startofrange" id="ch09-narc1"
          significance="normal">
          <primary>mesures de qualité de code</primary>

          <secondary sortas="CodeNarc">avec CodeNarc</secondary>
        </indexterm><indexterm class="startofrange" id="ch09-narc2"
          significance="normal">
          <primary>CodeNarc</primary>
        </indexterm><indexterm class="startofrange" id="ch09-narc3"
          significance="normal">
          <primary>Groovy scripts</primary>

          <secondary>mesures de qualité de code avec CodeNarc</secondary>
        </indexterm> outil d’analyse statique de code Groovy, similaire à PMD
      pour Java. Il vérifie le code source Groovy pour des défauts potentiels,
      des mauvais style et pratiques de codage, du code trop complexe, et
      ainsi de suite. Des règles typiques incluent « Constant If Expression »,
      « Empty Else Block », « GString As Map Key », et «Grails Stateless
      Service».</para>

      <para>Pour <indexterm id="I_indexterm9_d1e13180" significance="normal">
          <primary>Ant</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="CodeNarc">avec CodeNarc</tertiary>
        </indexterm><indexterm id="I_indexterm9_d1e13187"
          significance="normal">
          <primary>Maven</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="CodeNarc">avec CodeNarc</tertiary>
        </indexterm>des projets basés sur Maven ou Ant, le plugin Ant de
      CodeNarc est l’option la plus simple (un plugin Maven est en
      développement au moment de la rédaction). Une configuration typique de
      Ant pour l’utiliser avec Jenkins ressemblerait à ceci :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13195">&lt;taskdef name="codenarc" classname="org.codenarc.ant.CodeNarcTask"/&gt;
&lt;target name="runCodeNarc"&gt;
    &lt;codenarc ruleSetFiles="rulesets/basic.xml,rulesets/imports.xml"
              maxPriority1Violations="0"&gt;

        &lt;report type="xml"&gt;
            &lt;option name="outputFile" value="reports/CodeNarc.xml" /&gt;
        &lt;/report&gt;

        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.groovy"/&gt;
        &lt;/fileset&gt;
    &lt;/codenarc&gt;
&lt;/target&gt;</programlisting>

      <para>Vous <indexterm id="I_indexterm9_d1e13199" significance="normal">
          <primary>Grails</primary>

          <secondary>mesures de qualité de code avec CodeNarc</secondary>
        </indexterm>pouvez intégrer CodeNarc dans un projet Grails simplement
      en installant le plugin CodeNarc :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13205">$ grails install-plugin codenarc</programlisting>

      <para>Cela configurera CodeNarc pour analyser les fichiers Groovy dans
      le code de votre application Grails, aussi bien dans les
      répertoires<filename moreinfo="none"> src/groovy</filename> et <filename
      moreinfo="none">test</filename>.</para>

      <para>Gradle<indexterm id="I_indexterm9_d1e13217" significance="normal">
          <primary>Gradle</primary>

          <secondary>mesures de qualité de code</secondary>

          <tertiary sortas="CodeNarc">avec CodeNarc</tertiary>
        </indexterm> 0.8 fournit aussi une prise en charge de CodeNarc dans le
      plugin de qualité de code, que vous pouvez configurer dans vos builds
      comme montré ici :</para>

      <programlisting format="linespecific" id="I_programlisting9_d1e13225">apply plugin: 'code-quality'</programlisting>

      <para>Cela utilisera le fichier de configuration de CodeNarc dans
      <filename moreinfo="none">config/codenarc/codenarc.xml</filename> par
      défaut. Vous pouvez redéfinir cela avec la propriété
      <code>codeNarcConfigFileName</code>.</para>

      <para>Vous pouvez générer les rapports CodeNarc en exécutant <literal
      moreinfo="none">gradle codenarcMain</literal> ou, plus <indexterm
          class="endofrange" id="I_indexterm9_d1e13240" significance="normal"
          startref="ch09-narc1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13242"
          significance="normal" startref="ch09-narc2">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13244"
          significance="normal" startref="ch09-narc3">
          <primary/>
        </indexterm>simplement, <literal moreinfo="none">gradle
      check</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="sect-violations">
    <title>Rapports de problèmes de qualité de code avec le plugin
    Violations</title>

    <para>Un<indexterm class="startofrange" id="ch09-vio1"
        significance="normal">
        <primary>mesures de qualité de code</primary>

        <secondary sortas="Violations">avec le plugin Violations</secondary>
      </indexterm><indexterm class="startofrange" id="ch09-vio2"
        significance="normal">
        <primary>plugin Violations </primary>
      </indexterm><indexterm class="startofrange" id="ch09-vio3"
        significance="normal">
        <primary>plugins</primary>

        <secondary>Violations</secondary>
      </indexterm><indexterm class="startofrange" id="ch09-vio4"
        significance="normal">
        <primary>reporting</primary>

        <secondary>mesures de qualité de code</secondary>

        <tertiary>plugin Violations pour </tertiary>
      </indexterm> des plugins de qualité de code les plus utiles est le
    plugin Violation. Ce plugin n’analysera pas le code source de votre projet
    (vous devez configurer le build pour faire cela), mais il fait un
    excellent travail en élaborant des rapports sur les mesures de la qualité
    du code pour les builds individuels et les tendances au fil du temps. Le
    plugin s’adresse sur les mesures de qualité de code venant d’une large
    gamme d’outils d’analyse statique, y compris :</para>

    <variablelist>
      <varlistentry>
        <term>Pour Java</term>

        <listitem>
          <para>Checkstyle, CPD, PMD, FindBugs, and jcreport</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Pour Groovy</term>

        <listitem>
          <para>codenarc</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Pour JavaScript</term>

        <listitem>
          <para>jslint</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Pour .Net</term>

        <listitem>
          <para>gendarme and stylecop</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Installer le plugin est simple. Il suffit d’aller sur l’écran du
    Plugin Manager et de sélectionner le plugin Violations de Jenkins. Une
    fois que vous installé le plugin et redémarré Jenkins, vous serez capable
    de l’utiliser pour vos projets.</para>

    <para>Le plugin Violations ne génère pas de mesures de qualité de code
    lui-même—vous devez configurer votre build pour faire cela, comme montré
    dans la section précédente. Un exemple pour faire cela pour une tâche de
    build Maven est illustré dans la <xref
    linkend="fig-hudson-quality-goals"/>. Notez que nous invoquons ici les
    goals du plugin Maven directement. Nous aurions pu aussi juste exécuter
    <literal moreinfo="none">mvn site</literal>, mais si nous sommes
    uniquement intéressés par les mesures de qualité de code, et pas les
    autres éléments du site généré par Maven, appeler le plugin directement se
    traduira par des builds plus rapides.</para>

    <figure float="0" id="fig-hudson-quality-goals">
      <title>Générer les rapports de qualité de code dans un build
      Maven</title>

      <mediaobject id="I_mediaobject9_d1e13313">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0903.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0903.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Une fois que vous l’avez paramétré, vous pouvez configurer le plugin
    de violations pour générer des rapports, et si besoin est, des
    notifications de déclenchement, basés sur les résultats de rapport. Il
    suffit d’aller dans ‘Actions à la suite du build’ et de cocher la case à
    cocher Report Violations. Les détails de la configuration varient en
    fonction du type de projet. Regardons les tâches de build Freestyle dans
    un premier temps.</para>

    <sect2>
      <title>Travailler avec des tâches de build free-style</title>

      <para>Les<indexterm class="startofrange" id="ch09-freevio"
          significance="normal">
          <primary>les tâches de build free-style</primary>

          <secondary>mesures de qualité de code dans, avec
          Violations</secondary>
        </indexterm> tâches de build free-style vous permettent la
      configuration la plus flexible, et sont votre unique option pour des
      projets non Java.</para>

      <para>Lorsque vous utilisez le plugin Violation avec une tâche de build
      free-style, vous devez spécifier les chemins de chaque rapport XML
      généré par les outils d’analyse de code statiques que vous avez utilisé
      (voir <xref linkend="fig-hudson-quality-freestyle-violations"/>). Le
      plugin peut répondre à plusieurs rapports depuis le même outil, ce qui
      est utile pour des projets Maven multi-module—il suffit d’utiliser une
      expression générique pour identifier les rapports que vous voulez (par
      exemple, <literal
      moreinfo="none">**/target/checkstyle.xml</literal>).</para>

      <figure float="0" id="fig-hudson-quality-freestyle-violations">
        <title>Configurer le plugin violation pour un projet
        free-style</title>

        <mediaobject id="I_mediaobject9_d1e13341">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0904.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0904.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Le plugin Violations génèrera un graphique de suivi pour chaque
      type de problème dans le temps (voir <xref
      linkend="fig-hudson-quality-violations-graph"/>). Le graphique affiche
      une ligne de différente couleur pour chaque type de violations que vous
      suivez, aussi bien qu’un résumé des derniers résultats.</para>

      <figure float="0" id="fig-hudson-quality-violations-graph">
        <title>Les violations dans le temps</title>

        <mediaobject id="I_mediaobject9_d1e13353">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0905.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0905.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Vous pouvez aussi cliquer sur le graphique pour descendre vers un
      build particulier. Ici, vous pouvez voir le nombre de problème soulevé
      pour un build particulier (voir <xref
      linkend="fig-hudson-quality-violations-build"/>), avec diverses
      ventilations par type de violation, sévérité, et fichier.</para>

      <figure float="0" id="fig-hudson-quality-violations-build">
        <title>Les violations pour un build particulier</title>

        <mediaobject id="I_mediaobject9_d1e13365">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0906.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0906.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Enfin, vous pouvez descendre vers une classe particulière, pour
      afficher la liste détaillée des problèmes, le long d’où ils apparaissent
      dans le code source. </para>

      <para>Mais le plugin Violations permet aussi une gestion plus proactive
      de la qualité du code. Vous pouvez utiliser les résultats des rapports
      d’analyse de la qualité du code pour influencer l’icône du temps du
      tableau de bord de Jenkins. Cette icône du temps est normalement lié au
      nombre de builds défaillants des cinq builds précédents, mais Jenkins
      peut aussi prendre en compte d’autres facteurs, comme les résultats de
      la qualité du code. Afficher une icône pluvieuse ou orageuse pour un
      projet sur le tableau de bord est une meilleure façon de sensibiliser
      sur les problèmes de qualité du code que de simplement s’appuyer sur des
      graphiques et des rapports sur la page de la tâche de build.</para>

      <para>Pour le configurer, vous devez revenir dans la section Report
      Violations dans Actions à la suite du build. Les trois premières
      colonnes dans <xref linkend="fig-hudson-quality-freestyle-violations"/>
      montre une icône ensoleillé, un icône orageuse, et une balle jaune. Le
      premier avec l’icône de temps ensoleillé est le nombre maximum de
      violations tolérés pour garder l’icône ensoleillé sur la page du tableau
      de bord. La deuxième colonne, avec l’icône de temps orageux, est le
      nombre de violations qui causera l’affichage de l’icône orageuse sur le
      tableau de bord. Si vous avez un nombre de violations entre ces deux
      extrêmes, vous aurez l’une des icônes nuageuses.</para>

      <para>Vous pouvez spécifier différentes valeurs pour différents outils.
      Les seuils exacts varieront entre les équipes et entre les projets, et
      aussi entre les outils. Par exemple, Checkstyle soulèvera généralement
      beaucoup plus de problèmes que FindBugs ou CPD, avec PMD quelque part
      entre. Vous devez ajuster les valeurs utilisées pour refléter comment
      ces outils travaillent avec votre code de base, et vos attentes.</para>

      <para>Vous pouvez aller encore plus loin avec la troisième colonne
      (celle avec la balle jaune). Cette colonne vous permet de spécifier le
      nombre de violations qui déclarera le build comme <indexterm
          id="I_indexterm9_d1e13386" significance="normal">
          <primary>build jobs</primary>

          <secondary>unstable build from</secondary>

          <tertiary>criteria for</tertiary>
        </indexterm><indexterm id="I_indexterm9_d1e13393"
          significance="normal">
          <primary>les builds instables</primary>

          <secondary>criteria for</secondary>
        </indexterm>instable. Souvenez-vous, lorsqu’un build devient instable,
      Jenkins enverra des messages de notifications, donc c’est une stratégie
      encore plus proactive.</para>

      <para>Par exemple, dans <xref
      linkend="fig-hudson-quality-freestyle-violations"/>, nous avons
      configuré le nombre minimum des violations Checkstyle à 10, ce qui
      signifie que l’icône du temps ensoleillé apparaitra uniquement s’il y a
      10 violations Checkstyle ou moins. S’il y en a plus de 10, le temps se
      dégradera progressivement, jusqu’à 200 violations marqués, où il
      deviendra orageux. Et s’il y a 500 violations Checkstyle ou plus, le
      projet sera signalé instable.</para>

      <para>Maintenant regardez la configuration de CPD, le détecteur de code
      dupliqué qui viens avec PMD. Dans ce projet, nous avons adopté une
      politique zéro tolérance pour le code dupliqué, donc l’icône ensoleillé
      est spécifié à zéro. L’icône orageuse est spécifié à 10, donc s’il y a
      10 violations de copié/collé ou plus, il sera déclaré instable.</para>

      <para>Maintenant, sur la page du tableau de bord, le projet apparaitra
      avec à la fois un une icône de temps orageux et comme instable, même
      s’il n’y pas d’échecs de tests (voir <xref
      linkend="fig-hudson-quality-violations-rollover"/>). Ce build
      particulier est instable parce qu’il y a 16 violations CPD. En
      complément, si vous placez votre souris sur l’icône du temps, Jenkins
      affichera quelques détails en plus sur comment il a calculé ce statut
      <indexterm class="endofrange" id="I_indexterm9_d1e13409"
          significance="normal" startref="ch09-freevio">
          <primary/>
        </indexterm> particulier.</para>

      <figure float="none" id="fig-hudson-quality-violations-rollover">
        <title>Configurer le plugin de violations pour un projet
        free-style</title>

        <mediaobject id="I_mediaobject9_d1e13415">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0907.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0907.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Travailler avec des tâches de build Maven</title>

      <para>Les <indexterm class="startofrange" id="ch09-mavenvio"
          significance="normal">
          <primary> les tâches de build Maven</primary>

          <secondary>mesures de qualité de code dans, avec
          Violations</secondary>
        </indexterm>tâches de build Maven dans Jenkins utilisent les
      conventions de Maven et les informations du fichier <filename
      moreinfo="none">pom.xml</filename> du projet pour rendre la
      configuration plus facile et plus légère. Lorsque vous utilisez le
      plugin Violations avec une tâche de build Maven, Jenkins utilise ces
      conventions pour réduire la quantité de travail nécessaire pour
      configurer le plugin. Vous n’avez pas besoin de dire à Jenkins où
      trouver les rapports XML pour beaucoup d’outils d’analyse de code
      statique (par exemple, Checkstyle, PMD, FindBugs, et CPD), puisque
      Jenkins peut le comprendre depuis les conventions de Maven et les
      configurations du plugin (voir <xref
      linkend="fig-hudson-maven-violations"/>). Si vous devez surcharger ces
      conventions, vous pouvez choisir l’option Pattern dans la liste
      déroulante « XML filename pattern », et entrez le chemin comme vous
      pouvez le faire pour les tâches de build free-style.</para>

      <figure float="0" id="fig-hudson-maven-violations">
        <title>Configurer le plugin Violations pour un projet Maven.</title>

        <mediaobject id="I_mediaobject9_d1e13439">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0908.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0908.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Le plugin Violations travaille bien avec des projets multi-module
      Maven, mais au moment de la rédaction (de ce livre), il a besoin d’un
      peu de peaufinage pour obtenir de meilleurs résultats. Les tâches de
      build Maven comprennent la structure des projets multi-module (voir
      <xref linkend="fig-hudson-maven-modules"/>); de plus, vous pouvez
      descendre dans n’importe quel module et obtenir une vue détaillée des
      résultats de construction pour cette tâche de build.</para>

      <figure float="0" id="fig-hudson-maven-modules">
        <title>Les tâches de build Maven de Jenkins comprennent les structures
        multi-module de Maven</title>

        <mediaobject id="I_mediaobject9_d1e13451">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0909.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0909.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>C’est une fonctionnalité très utile, mais cela signifie que vous
      devez faire un peu de travail supplémentaire pour obtenir tous les
      avantages des plugins de violations des modules individuels. Par défaut,
      le plugin Violations affichera une vue agrégée des mesures de qualité de
      code comme celle dans <xref
      linkend="fig-hudson-quality-violations-graph"/>. Vous pouvez aussi
      cliquer sur le graphique des violations, et voir les rapports détaillés
      de chaque module.</para>

      <para>Cependant, pour que ceci puisse fonctionner correctement, vous
      devez activer le plugin Violations individuellement pour chaque module
      en complément du projet principal. Pour se faire, cliquez sur le module
      que vous voulez configurer dans l’écran Modules, et ensuite cliquez sur
      le menu ‘Configurer’. Ici, vous verrez un petit groupe des options de
      configuration habituelles (voir <xref
      linkend="fig-hudson-violations-module-config"/>). Ici, il vous suffit
      d’activer l’option Violations, et de configurer les seuils si c’est
      requis. Sur le côté positif, cela signifie que vous pouvez définir
      différents valeurs de seuils pour des modules différents.</para>

      <figure float="0" id="fig-hudson-violations-module-config">
        <title>Activer le plugin Violations pour un module individuel</title>

        <mediaobject id="I_mediaobject9_d1e13467">
          <imageobject role="print">
            <imagedata fileref="figs/print/jtdg_0910.pdf" format="PDF"/>
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/jtdg_0910.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Une fois que vous avez fait ceci, lorsque vous cliquez sur le
      graphique de violations agrégées sur la page d’accueil de la tâche de
      build du projet, Jenkins listera les graphiques individuels de
      violations pour chaque <indexterm class="endofrange"
          id="I_indexterm9_d1e13474" significance="normal"
          startref="ch09-mavenvio">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13476"
          significance="normal" startref="ch09-vio1">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13478"
          significance="normal" startref="ch09-vio2">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13480"
          significance="normal" startref="ch09-vio3">
          <primary/>
        </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13482"
          significance="normal" startref="ch09-vio4">
          <primary/>
        </indexterm> module.</para>
    </sect2>
  </sect1>

  <sect1 id="sect-code-quality-checkstyle">
    <title>Utiliser les rapports Checkstyle, PMD, et FindBugs</title>

    <para>Vous <indexterm id="I_indexterm9_d1e13490" significance="normal">
        <primary>FindBugs</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13493" significance="normal">
        <primary>mesures de qualité de code</primary>

        <secondary sortas="FindBugs">avec FindBugs</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13498" significance="normal">
        <primary>rapports</primary>

        <secondary>mesures de qualité du code</secondary>

        <tertiary sortas="FindBugs">avec FindBugs</tertiary>
      </indexterm><indexterm id="I_indexterm9_d1e13505" significance="normal">
        <primary>Checkstyle</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13508" significance="normal">
        <primary>PMD</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13511" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary sortas="Checkstyle">avec Checkstyle</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13516" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary sortas="PMD">avec PMD</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13521" significance="normal">
        <primary>rapport</primary>

        <secondary>mesures de qualité de code</secondary>

        <tertiary sortas="Checkstyle">avec Checkstyle</tertiary>
      </indexterm><indexterm id="I_indexterm9_d1e13528" significance="normal">
        <primary>rapports</primary>

        <secondary>mesures de qualité de code</secondary>

        <tertiary sortas="PMD">avec PMD</tertiary>
      </indexterm>pouvez aussi effectuer des rapports individuellement sur les
    résultats de Checkstyle, PMD, et FindBugs. En complément du plugin
    Violations, il y a aussi des plugins Jenkins qui produisent des graphique
    de tendance et des rapports détaillés pour chaque de ces outils
    individuellement. Nous allons voir comment faire ceci pour Checkstyle,
    mais la même approche s’applique aussi pour PMD et FindBugs. Vous pouvez
    même utiliser le plugin Analysis Collector pour afficher les résultats
    combinés dans un graph similaire de celui produit par le plugin
    violation.</para>

    <?dbfo-need height=”1in”?>

    <para>Vous <indexterm id="I_indexterm9_d1e13539" significance="normal">
        <primary>Checkstyle plugin</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13542" significance="normal">
        <primary>PMD plugin</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13545" significance="normal">
        <primary>FindBugs plugin</primary>
      </indexterm><indexterm id="I_indexterm9_d1e13548" significance="normal">
        <primary>plugins</primary>

        <secondary>Checkstyle</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13553" significance="normal">
        <primary>plugins</primary>

        <secondary>PMD</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13558" significance="normal">
        <primary>plugins</primary>

        <secondary>FindBugs</secondary>
      </indexterm>pouvez installer ces plugins au travers du gestionnaire de
    plugin de manière habituelle. Les plugins en question sont appelés, sans
    surprise, le plugin Checkstyle, le plugin PMD, et le plugin FindBugs. Tout
    ces plugins utilisent le plugin Static Analysis Utilities qui vous avez
    aussi besoin d’installer (voir <xref
    linkend="fig-hudson-analysis-plugins"/>).</para>

    <figure float="none" id="fig-hudson-analysis-plugins">
      <title>Installer les plugins Checkstyle et Static Analysis
      Utilities.</title>

      <mediaobject id="I_mediaobject9_d1e13569">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0911.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0911.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Une fois que vous avez installé ces plugins, vous pouvez spécifier
    la déclaration dans la configuration de votre projet. Cochez la case
    "Publiez les analyses de résultat Checkstyle". Dans un build free-style,
    vous aurez besoin de spécifier le patron du chemin pour trouver les
    rapports XML de Checkstyle ; dans un build Maven 2, Jenkins comprendrait
    où les chercher par lui-même.</para>

    <para>Ceci fournira des rapports Checkstyle basiques, mais comme
    d’habitude, vous pouvez affiner les choses en cliquant sur le bouton
    Avancé. Dans un build Maven 2, vous pouvez configurer les valeurs de
    seuils de la santé (combien de violations passeront le build de ensoleillé
    à orageux), et aussi filtrer les priorités de violations que vous voulez
    inclure dans le calcul. Par exemple, vous pourriez seulement vouloir
    prendre en compte les problèmes de hautes priorités pour le statut de
    l’icône de temps.</para>

    <para>Les builds free-style ont quelques options supplémentaires que vous
    pouvez configurer ; en particulier, vous pouvez rendre le build <indexterm
        id="I_indexterm9_d1e13580" significance="normal">
        <primary>build jobs</primary>

        <secondary>unstable build from</secondary>

        <tertiary>criteria for</tertiary>
      </indexterm><indexterm id="I_indexterm9_d1e13587" significance="normal">
        <primary>unstable builds</primary>

        <secondary>criteria for</secondary>
      </indexterm>instable instable (balle jaune) ou même en échec (balle
    rouge) si vous avez plus qu’un nombre de violations, ou si il y a plus
    qu’un nombre donné de nouvelle violations (voir <xref
    linkend="fig-hudson-checkstyle-config"/>). Donc, dans la configuration
    dans l’illustration, s’il y a plus de 50 nouvelles violations Checkstyle
    sur n’importe quelle priorité dans un build, el build sera signalé comme
    instable. Cela a certainement son utilité pour Checkstyle, mais cela peut
    aussi se révéler très utile avec FindBugs, ou les problèmes de hautes
    priorités représentent souvent des bugs dangereux et potentiellement
    difficile à arrêter. </para>

    <figure float="0" id="fig-hudson-checkstyle-config">
      <title>Configurer le plugin Checkstyle</title>

      <mediaobject id="I_mediaobject9_d1e13598">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0912.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0912.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Maintenant, lorsque le build démarre, Jenkins générera maintenant un
    graphique de tendance et des rapports détaillés pour les violations
    Checkstyle (voir <xref linkend="fig-hudson-checkstyle-trend"/>). De là,
    vous pouvez descendre pour voir les violations par priorité, par
    catégorie, par type de démarrage, par package, et ainsi de suite.</para>

    <figure float="0" id="fig-hudson-checkstyle-trend">
      <title>Afficher les tendances Checkstyle</title>

      <mediaobject id="I_mediaobject9_d1e13610">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0913.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0913.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <?dbfo-need height=”1in”?>

    <para>Comme nous l’avions mentionné plus tôt, la même approche marche
    aussi avec le plugin PMD et le plugin FindBugs. Ces plugins sont un
    excellent moyen de fournir des rapports plus concentrés sur les résultats
    d’un outil particulier, et vous donnent aussi plus de contrôle sur
    l’impact que ces violations auront sur les résultats du build.</para>
  </sect1>

  <sect1 id="sect-code-quality-complexity">
    <title>Les rapports sur la complexité du code</title>

    <para>La complexité du code<indexterm class="startofrange"
        id="ch09-complex1" significance="normal">
        <primary>mesures de qualité de code</primary>
      </indexterm><indexterm class="startofrange" id="ch09-complex2"
        significance="normal">
        <primary>complexité du code</primary>
      </indexterm> est un autre aspect important de la qualité du code. La
    complexité du code est mesurée avec un certain nombre de moyens, mais une
    mesure de complexité généralement utilisée (et facile à comprendre) est la
    complexité cyclomatique, qui consiste à mesurer le nombre de chemins
    différents à travers une méthode. En utilisant cette métrique, le code
    complexe a généralement un grand nombre d’instructions conditionnelles
    imbriqués et de boucles, qui rendent le code plus difficile à comprendre
    et à déboguer. </para>

    <para>Il y a aussi une théorie de qualité de code mettant en corrélation
    la complexité du code et la couverture du code, pour donner une idée
    générale de la fiabilité d’une portion de code. Ceci est basé sur l’idée
    (très compréhensible) que le code qui est à la fois complexe et peu testé
    est plus susceptible de contenir des bugs que du code simple, et bien
    testé.</para>

    <para>Le<indexterm id="I_indexterm9_d1e13637" significance="normal">
        <primary>plugins</primary>

        <secondary>Coverage Complexity Scatter Plot</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13642" significance="normal">
        <primary>Coverage Complexity Scatter Plot plugin</primary>
      </indexterm> Coverage Complexity Scatter Plot est conçu pour vous
    laissez visualiser cette information dans vos builds Jenkins (voir <xref
    linkend="fig-hudson-coverage-complexity"/>). Les méthodes dangereusement
    complexes et/ou non testées apparaitront hautes sur le graphique, alors
    que les méthodes bien écrites et bien testées apparaitront plus
    basses.</para>

    <figure float="none" id="fig-hudson-coverage-complexity">
      <title>Un nuage de point couverture/complexité.</title>

      <mediaobject id="I_mediaobject9_d1e13654">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0914.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0914.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Le graphique de dispersion vous donne un bon aperçu de l’état de
    votre code en termes de complexité de couverture de test, mais vous pouvez
    aussi descendre pour poursuivre l’enquête. Si vous cliquez sur n’importe
    quel point dans le graphique, vous pouvez voir les méthodes
    correspondantes, avec leur couverture de test et leur complexité (voir
    <xref linkend="fig-hudson-coverage-complexity-details"/>).</para>

    <figure float="0" id="fig-hudson-coverage-complexity-details">
      <title>Vous pouvez cliquer sur n’importe quel point du graphique pour
      poursuivre l’enquête</title>

      <mediaobject id="I_mediaobject9_d1e13666">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0915.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0915.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <?dbfo-need height=”1in”?>

    <para>Au moment de la rédaction de ce livre, le plugin nécessite Clover,
    donc votre build a besoin d’avoir généré un rapport XML de couverture de
    Clover, et vous avez besoin d’avoir installé et configuré le plugin Clover
    de Jenkins (voir <xref linkend="sect-clover"/>). Cependant, un support
    pour Cobertura et d’autres outils<indexterm class="endofrange"
        id="I_indexterm9_d1e13676" significance="normal"
        startref="ch09-complex1">
        <primary/>
      </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13678"
        significance="normal" startref="ch09-complex2">
        <primary/>
      </indexterm> est prévu.</para>
  </sect1>

  <sect1 id="sect-code-quality-open-tasks">
    <title>Les rapports sur les tâches ouvertes</title>

    <para>Quant<indexterm class="startofrange" id="ch09-open1"
        significance="normal">
        <primary>mesures de qualité de code</primary>

        <secondary>tâches ouvertes</secondary>
      </indexterm><indexterm class="startofrange" id="ch09-open2"
        significance="normal">
        <primary>tâches ouvertes, rapport sur </primary>
      </indexterm><indexterm class="startofrange" id="ch09-open3"
        significance="normal">
        <primary>rapport</primary>

        <secondary>mesures de qualité de code</secondary>

        <tertiary>tâches ouvertes</tertiary>
      </indexterm> il s’agit de qualité de code, l’analyse statique n’est pas
    le seul outil que vous pouvez utiliser. Un autre indicateur de la santé
    générale de votre projet peut être trouvé avec le nombre de <literal
    moreinfo="none">FIXME</literal>, <literal moreinfo="none">TODO</literal>,
    <literal moreinfo="none">@deprecated</literal>, et d’autres balises
    similaires dispersées dans le code source. S’il y en a beaucoup, cela peut
    être un signe que le code de base a beaucoup de travail inachevé, et n’est
    donc pas dans un état très finalisé.</para>

    <para>Le<indexterm id="I_indexterm9_d1e13713" significance="normal">
        <primary>plugins</primary>

        <secondary>Task Scanners</secondary>
      </indexterm><indexterm id="I_indexterm9_d1e13718" significance="normal">
        <primary>Task Scanners plugin</primary>
      </indexterm> plugin Task Scanners de Jenkins permet de garder une trace
    de ces sortes de balises dans votre code source, et optionnellement
    signaler un build avec une mauvaise icône de temps sur le tableau de bord
    s’il y a beaucoup trop de tâches ouvertes.</para>

    <para>Pour le configurer, vous devez installer à la fois le plugin Static
    Analysis Utilities et le plugin Task Scanner. Une fois installés, vous
    pouvez activer le plugin dans votre projet en cochant la case « Recherche
    des tâches ouvertes dans le workspace » dans la section Configuration du
    Build dans la configuration de la tâche de votre projet.</para>

    <para>Configurer le plugin Task Scanner est assez simple (voir <xref
    linkend="fig-hudson-task-scanner"/>). Vous entrez simplement les balises
    que vous souhaitez suivre, avec différentes priorités si vous considérez
    certaines balises comme étant plus importantes que d’autres. Par défaut,
    le plugin scrutera tout le code source java dans le projet, mais vous
    redéfinir ce comportement en entrant le champ Files to scan. In <xref
    linkend="fig-hudson-task-scanner"/>, for example, we also check XML and
    JSP files for tags.</para>

    <figure float="0" id="fig-hudson-task-scanner">
      <title>Configurer le plugin Task Scanner est simple</title>

      <mediaobject id="I_mediaobject9_d1e13733">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0916.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0916.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Le bouton Avancé vous donne accès à des options plus sophistiqués.
    Probablement le plus utiles sont les seuils de santé, qui vous laisse
    définir le nombre maximum de problèmes tolérés avant que le build ne soit
    plus considéré « ensoleillé », et le nombre minimum de problèmes requis
    pour le statut de « temps orageux ».</para>

    <para>Le plugin génère un graphique qui montre les tendances de balises
    par ordre de priorité (voir <xref
    linkend="fig-hudson-task-scanner-report"/>). Si vous cliquez sur le
    rapport des tâches ouvertes, vous pouvez aussi voir le détail des tâches
    par module Maven, package ou fichier, ou encore une liste des
    tâches<indexterm class="endofrange" id="I_indexterm9_d1e13744"
        significance="normal" startref="ch09-open1">
        <primary/>
      </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13746"
        significance="normal" startref="ch09-open2">
        <primary/>
      </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13748"
        significance="normal" startref="ch09-open3">
        <primary/>
      </indexterm> ouvertes.</para>

    <figure float="0" id="fig-hudson-task-scanner-report">
      <title>Le graphique de tendances des tâches ouvertes</title>

      <mediaobject id="I_mediaobject9_d1e13754">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0917.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0917.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <?dbfo-need height=”1in”?>

  <sect1 id="sect-code-quality-sonar">
    <title>Intégration avec Sonar</title>

    <para><ulink url="http://www.sonarsource.org">Sonar</ulink><indexterm
        class="startofrange" id="ch09-sonar1" significance="normal">
        <primary>mesures de qualité du code</primary>

        <secondary sortas="Sonar">with Sonar</secondary>
      </indexterm><indexterm class="startofrange" id="ch09-sonar2"
        significance="normal">
        <primary>Sonar</primary>

        <secondary>les mesures de qualité de code avec</secondary>
      </indexterm> est un outil qui centralise toute une gamme de mesures de
    qualité de code dans un seul site web (voir <xref
    linkend="fig-hudson-sonar"/>). Il utilise un certain nombre de plugins
    Maven (Checkstyle, PMD, FindBugs, Cobertura ou Clover, et d’autres) pour
    analyser des projets Maven et générer un ensemble compréhensible de
    rapports sur la qualité du code. Les rapports Sonar sur la couverture du
    code, le respect des règles, et la documentation, mais aussi sur des
    mesures de plus haut niveau comme la complexité, la maintenabilité et même
    la dette technique. Vous pouvez utiliser des plugins pour étendre ses
    fonctionnalités et ajouter le support pour d’autres langages (comme le
    support de CodeNarc pour du code source Groovy). Les règles utilisées par
    divers outils sont gérées et configurées de manière centralisée sur le
    site web de Sonar, et les projets Maven en cours d’analyse ne nécessitent
    aucune configuration particulière. Cela fait de Sonar un ajustement
    parfait pour travailler sur des projets Maven où vous avez un contrôle
    limité sur les fichiers POM.</para>

    <figure float="0" id="fig-hudson-sonar">
      <title>Rapport de qualité de code par Sonar.</title>

      <mediaobject id="I_mediaobject9_d1e13785">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0918.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0918.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Dans l’une des utilisations les plus courantes de Sonar, Sonar
    démarre automatiquement un ensemble de plugins liés à la qualité de code
    de Maven sur votre projet Maven, et stocke les résultats dans une base de
    données relationnelle. Le serveur Sonar, que vous démarrez séparément,
    analyse alors les résultats et affiche les résultats comme indiqué dans
    <xref linkend="fig-hudson-sonar"/>.</para>

    <para>Jenkins s’intègre bien avec Sonar. Le plugin Sonar de Jenkins vous
    laisse définir les instances Sonar pour tous vos projets, et active
    ensuite Sonar pour des builds particuliers. Vous pouvez démarrer votre
    serveur Sonar sur une machine différente de votre instance Jenkins, ou sur
    la même. La seule contrainte est que l’instance Jenkins doit avoir un
    accès JDBC à la base de données de Sonar, puisqu’il injecte des mesures de
    qualité de code directement dans la base de données, sans passer par le
    site web de Sonar (voir <xref
    linkend="fig-hudson-sonar-architecture"/>).</para>

    <figure float="0" id="fig-hudson-sonar-architecture">
      <title>Jenkins et Sonar</title>

      <mediaobject id="I_mediaobject9_d1e13801">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0919.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0919.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Sonar a aussi une amorce Ant (avec une amorce Gradle en train d’être
    construite durant la rédaction de ce livre) pour les utilisateurs
    non-Maven.</para>

    <para>Vous installez le plugin comme d’habitude, via le gestionnaire de
    plugin. Une fois installé, vous configurez le plugin Sonar de Jenkins dans
    l’écran Configurer le système, dans la section Sonar. Il s’agit de définir
    vos instances Sonar – vous pouvez configurer autant d’instances que vous
    avez besoin. La configuration par défaut assume que vous exécutez une
    instance locale de Sonar avec la base de données imbriquée par défaut.
    Ceci est utile à des fins de test, mais n’est pas très évolutif. Pour un
    environnement de production, vous démarrera typiquement Sonar sur une base
    de données réelle comme MySQL ou Postgres, et vous aurez besoin de
    configurer la connexion JDBC sur la base de données de production de Sonar
    dans Jenkins. Vous pouvez faire ceci en cliquant le bouton Avancé et en
    remplissant les champs appropriés (voir <xref
    linkend="fig-hudson-sonar-config"/>).</para>

    <figure float="0" id="fig-hudson-sonar-config">
      <title>Configurer Sonar dans Jenkins</title>

      <mediaobject id="I_mediaobject9_d1e13815">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0920.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0920.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>L’autre chose que vous devez configurer est quand le build de Sonar
    sera débutera dans une tâche de build où Sonar est activé. Vous configurez
    généralement Sonar pour démarrer avec l’une des longues tâches de build
    Jenkins, comme le build de mesure de qualité de code. Ce n’est pas très
    utile de démarrer le build Sonar plus d’une fois par jour, puisque Sonar
    stocke les mesures sur des tranches de 24 heures. La configuration par
    défaut démarrera le build Sonar dans une tâche de build où est activé
    Sonar chaque fois qu’une tâche est déclenchée par une build périodiquement
    planifié ou par un build manuel.</para>

    <para>Pour activer Sonar une tâche de build avec des options de
    configuration à l’échelle du système, il suffit de cocher l’option Sonar
    dans Actions à la suite du build (voir <xref
    linkend="fig-hudson-sonar-config-job"/>). Sonar démarrera à chaque fois
    que votre build commencera par l’un des mécanismes de déclenchements
    définis ci-dessus.</para>

    <figure float="0" id="fig-hudson-sonar-config-job">
      <title>Configurer Sonar dans une tâche de build</title>

      <mediaobject id="I_mediaobject9_d1e13830">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0921.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0921.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Vous configurez généralement Sonar pour démarrer sur une base
    régulière, par exemple tous les soirs ou une fois par semaine. Donc vous
    pouvez activer Sonar sur votre tâche de build de test
    unitaire/d’intégration normal, simplement en ajoutant un ordonnanceur
    (voir <xref linkend="fig-hudson-sonar-build-schedule"/>). Cela évite les
    détails de configuration en double entre les tâches. Ou, si vous avez déjà
    une tâche de build ordonnancée qui démarre avec une fréquence appropriée
    (comme un build dédié aux mesures de qualité de code), vous pouvez activer
    Sonar sur cette tâche de build.</para>

    <figure float="0" id="fig-hudson-sonar-build-schedule">
      <title>Planifier les builds Sonar</title>

      <mediaobject id="I_mediaobject9_d1e13842">
        <imageobject role="print">
          <imagedata fileref="figs/print/jtdg_0922.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="figs/web/jtdg_0922.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <?dbfo-need height=”1in”?>

    <para>Si vous cliquez sur le bouton Avancé, vous pouvez spécifier d’autres
    options plus sophistiquées, comme lancer votre build Sonar sur une branche
    séparée, passer des options de ligne de commande Maven supplémentaires
    (comme de la mémoire supplémentaire), ou redéfinir la configuration par
    défaut des déclencheurs.</para>

    <para>Par défaut, Sonar démarrera même si le build normal échoue. C’est
    généralement ce que l’on souhaite, puisque Sonar devrait enregistrer les
    builds et les tests défaillants aussi bien que les résultats réussis.
    Cependant, si c’est requis, vous pouvez désactiver cette option aussi dans
    les options<indexterm class="endofrange" id="I_indexterm9_d1e13855"
        significance="normal" startref="ch09-sonar1">
        <primary/>
      </indexterm><indexterm class="endofrange" id="I_indexterm9_d1e13857"
        significance="normal" startref="ch09-sonar2">
        <primary/>
      </indexterm> avancées.</para>
  </sect1>

  <?dbfo-need height=”2in”?>

  <sect1 id="sect-code-quality-conclusion">
    <title>Conclusion</title>

    <para>La qualité de code est une partie importante du processus de build,
    et Jenkins fournit un excellent support pour la vaste gamme d’outils liés
    à la qualité de code qu’il y a. En conséquence, Jenkins devrait être un
    élément clé de votre stratégie sur la qualité du code.</para>
  </sect1>
</chapter>
